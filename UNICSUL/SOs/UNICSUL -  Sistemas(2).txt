UNICSUL - Ciberseguran√ßa - Sistemas Operacionais - Aula 2

üîß 1. Fun√ß√£o do Sistema Operacional (SO)
	- O Sistema Operacional √© respons√°vel por gerenciar todos os recursos do computador, como CPU, mem√≥ria, arquivos e dispositivos de entrada/sa√≠da.
	- Ele controla a execu√ß√£o dos processos, permitindo que diversos programas sejam executados ao mesmo tempo (multiprograma√ß√£o), oferecendo ao usu√°rio a impress√£o de paralelismo.

‚öôÔ∏è 2. Gerenciamento de Processos
	- Processo: Programa em execu√ß√£o, com contexto e recursos associados. Diferente do programa, que √© est√°tico e armazenado no disco, o processo √© din√¢mico e reside na mem√≥ria.
	- Um mesmo programa pode originar v√°rios processos se o SO permitir reentr√¢ncia.
	- Cada processo possui um contexto de execu√ß√£o, que inclui:
		- PID (identificador do processo),
		- Registradores (PC ‚Äì Program Counter, SP ‚Äì Stack Pointer),
		- Vari√°veis, arquivos, prioridade, tempo de CPU e eventos esperados.

üìã 3. Bloco de Controle de Processo (BCP)
	- Estrutura de dados com todas as informa√ß√µes necess√°rias para gerenciar e retomar a execu√ß√£o de um processo.
	- Quando o processo √© interrompido, seu contexto √© salvo no BCP, permitindo retom√°-lo do ponto exato onde parou (evitando perda de dados).

üîÑ 4. Mudan√ßa de Contexto (Context Switching)
	- Troca de execu√ß√£o entre processos concorrentes.
	- O SO salva o contexto do processo atual no BCP e carrega o contexto do pr√≥ximo processo a ser executado.
	- Essencial para garantir a utiliza√ß√£o eficiente da CPU.

üåÄ 5. Estados de um Processo
	- Cria√ß√£o: Quando o processo √© gerado.
	- Pronto (Ready): Esperando para ser executado.
	- Execu√ß√£o (Running): Est√° usando a CPU.
	- Bloqueado (Blocked): Aguardando um evento externo (E/S, dados).
	- Encerrado (Terminated): Processo finalizado.

üìà 6. Filas de Controle
	- Ready List: Fila de processos prontos para execu√ß√£o.
	- Blocked List: Fila de processos que est√£o aguardando algum evento.
	- O escalonador (scheduler) √© respons√°vel por organizar essas filas e decidir qual processo ser√° executado.

üìÖ 7. Escalonamento de Processos
	- Define a ordem em que os processos usam a CPU.
	- Tipos de escalonamento:
		- Preemptivo: Um processo pode ser interrompido antes de terminar sua execu√ß√£o.
		- N√£o-preemptivo: Um processo s√≥ libera a CPU voluntariamente (ap√≥s terminar).

üìä 8. Crit√©rios para Escolha de Algoritmo de Escalonamento
	- Justi√ßa: Todos devem ter acesso √† CPU.
	- Efici√™ncia: Maximizar o uso da CPU.
	- Tempo de Resposta: Tempo entre envio da tarefa e resposta.
	- Throughput (Vaz√£o): N√∫mero de tarefas conclu√≠das por tempo.
	- Turnaround Time: Tempo total de execu√ß√£o de um job.

üß† 9. Principais Algoritmos de Escalonamento
	- FIFO (FCFS) ‚Äì Primeiro a entrar, primeiro a sair. Simples, por√©m n√£o ideal para tarefas interativas.
	- Round Robin ‚Äì Cada processo recebe uma fatia de tempo (quantum). Ap√≥s o tempo, volta para o fim da fila.
	- Prioridade ‚Äì Processos com maior prioridade executam primeiro.
		- Pode usar prioridades est√°ticas ou din√¢micas.
		- Para evitar monop√≥lio, a prioridade pode ser reduzida com o tempo.
	- Shortest Job First (SJF) ‚Äì Executa o processo com menor tempo estimado. Reduz tempo m√©dio de espera.
	- Escalonamento por Deadline ‚Äì Usado em sistemas de tempo real. Processos devem ser executados antes de um prazo.
	- Escalonamento com Garantia ‚Äì Distribui CPU igualmente entre usu√°rios.
	- Escalonamento em Dois N√≠veis ‚Äì Para casos com pouca mem√≥ria. Um n√≠vel escolhe os processos da mem√≥ria, outro lida com swapping (disco).

üßÆ 10. T√©cnica de Aging (Envelhecimento)
	- T√©cnica para estimar o tempo de execu√ß√£o de processos baseado em hist√≥ricos anteriores.
	- F√≥rmula comum: Estimativa = a * T_anterior + (1 - a) * T_atual.
	- Permite melhorar algoritmos como SJF em ambientes interativos.

‚ö° 11. Interrup√ß√µes
	- Mecanismo que permite ao SO interromper um processo para realizar alguma a√ß√£o importante.
	- Tipos de Interrup√ß√£o:
		- De Software: Solicita√ß√£o de servi√ßos do SO.
		- De Entrada/Sa√≠da (E/S): Eventos vindos de dispositivos (teclado, impressora etc.).
		- Traps: Causadas por erros de execu√ß√£o (ex: divis√£o por zero).
	- O SO salva o contexto do processo e executa uma rotina de tratamento da interrup√ß√£o.

üßµ 12. Threads (Linhas de Execu√ß√£o Leve)
	üìå Conceito
		- As threads s√£o unidades menores de execu√ß√£o dentro de um processo.
		- Permitem que diferentes partes do mesmo programa sejam executadas simultaneamente, implementando multitarefa dentro do pr√≥prio processo.
	üîÑ Modelo Tradicional vs Modelo com Threads
		- Modelo Tradicional: O programa possui uma √∫nica thread, ou seja, uma √∫nica linha de execu√ß√£o sequencial (as instru√ß√µes s√£o executadas uma ap√≥s a outra, do in√≠cio ao fim).
		- Modelo com Threads: Um processo pode conter v√°rias threads, que compartilham os mesmos recursos do processo (mem√≥ria, arquivos, etc.), mas executam trechos diferentes de c√≥digo simultaneamente.
	üß† Funcionamento pr√°tico das Threads
		- Ao usar threads, n√£o ocorre uma simples chamada de fun√ß√£o tradicional, onde o controle do fluxo √© transferido para a fun√ß√£o.
		- Em vez disso, ambas as threads (a chamadora e a nova thread criada) continuam executando em paralelo/concorrem pelo uso da CPU, como se fossem tarefas independentes.
	üí° Vantagens do uso de Threads
		- Melhor desempenho em sistemas multiprocessados ou multin√∫cleo.
		- Maior efici√™ncia na execu√ß√£o de tarefas simult√¢neas, como:
		- Um programa que l√™ dados do disco enquanto processa dados j√° carregados.
		- Aplica√ß√µes com interface gr√°fica que continuam responsivas enquanto executam tarefas pesadas em segundo plano.
		- Compartilhamento facilitado de dados entre partes do c√≥digo, j√° que todas as threads compartilham o mesmo espa√ßo de mem√≥ria.
	‚ö†Ô∏è Cuidados com o uso de Threads
		- Como compartilham mem√≥ria, pode haver problemas de concorr√™ncia, como:
		- Condi√ß√µes de corrida (race conditions),
		- Erros de sincroniza√ß√£o (deadlocks, starvation),
		- Acesso inconsistente a dados.
		- √â necess√°rio usar mecanismos de sincroniza√ß√£o (como mutexes, sem√°foros, monitores) para garantir a integridade dos dados.

	